<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>SPECK – Confronta Spettri</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.0/dist/chartjs-plugin-zoom.umd.min.js"></script>
<style>
  html,body{margin:0;height:100%;background:#111;color:#ecf0f1;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;}
  #topBar{display:flex;gap:18px;align-items:center;background:#000;padding:10px 20px;position:fixed;top:0;left:0;right:0;z-index:10}
  #topBar label{cursor:pointer;font-weight:bold;color:#1abc9c}
  #chips{flex:1;display:flex;flex-wrap:wrap;gap:6px}
  .chip{background:#444;border-radius:14px;padding:2px 10px;font-size:.8rem;cursor:pointer;transition:.2s}
  .chip:hover{background:#c0392b}
  #ccdWrap canvas{width:100%!important;height:120px;margin-bottom:4px;border:1px solid #555}
  #chartWrap{position:absolute;top:56px;bottom:0;left:0;right:0;padding:10px}
  #ccdOverlay{
    position:fixed;top:56px;left:0;right:0;bottom:0;
    background:rgba(0,0,0,0.92);display:none;overflow-y:auto;padding:20px;
  }
  #ccdOverlay canvas{width:100%!important;height:140px;margin-bottom:10px;border:1px solid #555}
  #closeCCD{
    position:fixed;top:60px;right:20px;padding:4px 8px;font-size:18px;
    background:#c0392b;border:none;color:#fff;border-radius:4px;cursor:pointer;
  }
  canvas{width:100%!important;height:100%!important}
  .ccdRow{position:relative;margin-bottom:12px}
  .ccdRow span{position:absolute;left:8px;bottom:6px;font-size:.8rem;color:#fff;background:rgba(0,0,0,.6);padding:2px 6px;border-radius:4px;opacity:0;transition:.2s}
  .ccdRow:hover span{opacity:1}
</style>
</head>
<body>
  <div id="topBar">
    <label for="picker" style="font-weight:bold;color:#1abc9c">Aggiungi spettro:</label>
    <select id="picker" style="padding:4px 8px;background:#222;color:#ecf0f1;border:1px solid #555;">
      <option value="" disabled selected>— seleziona —</option>
    </select>

    <label style="color:#ccc;font-size:.85rem;">
      <input type="checkbox" id="chkLogY">
      Log&nbsp;Y
    </label>

    <button id="btnNorm"
            style="padding:4px 10px;background:#3498db;border:none;border-radius:4px;color:#fff;font-weight:bold;cursor:pointer;">
      Normalize
    </button>

    <button id="btnCCD"
            style="padding:4px 10px;background:#1abc9c;border:none;border-radius:4px;color:#fff;font-weight:bold;cursor:pointer;">
      Mostra&nbsp;CCD
    </button>

    <div id="chips"></div>
  </div><!-- end #topBar -->

  <div id="chartWrap"><canvas id="cmpChart"></canvas></div>

  <!-- Overlay for CCD images -->
  <div id="ccdOverlay">
    <button id="closeCCD">✕</button>
    <div id="ccdInner"></div>
  </div>

<script>
// === CONFIG ===
const DATA_DIR  = 'csv_out';
const LIST_FILE = 'titoli.json';
// ==============

const colours=['#e74c3c','#3498db','#1abc9c','#f1c40f','#9b59b6','#e67e22','#2ecc71','#8e44ad'];
let datasets=[];
let logY=false, normalized=false;
function hex2rgb(hex){hex=hex.replace('#','');if(hex.length===3)hex=hex.split('').map(c=>c+c).join('');const num=parseInt(hex,16);return[(num>>16)&255,(num>>8)&255,num&255];}
function refreshColours(){
  datasets.forEach(ds=>{
    const [r,g,b]=hex2rgb(ds.baseColor||ds.borderColor);
    const a=ds.opacity??1;
    ds.borderColor=`rgba(${r},${g},${b},${a})`;
  });
}

const chart=new Chart(document.getElementById('cmpChart').getContext('2d'),{
  type:'line',
  data:{datasets},
  options:{
    responsive:true,maintainAspectRatio:false,
    plugins:{
      legend:{position:'bottom'},
      zoom:{
        pan:{enabled:true,mode:'xy'},
        zoom:{wheel:{enabled:true},pinch:{enabled:true},mode:'xy'}
      }
    },
    scales:{x:{type:'linear',title:{display:true,text:'λ (nm)'}},
            y:{title:{display:true,text:'Intensità (a.u.)'}}}
  }
});

(async function loadList(){
  try{
    const res = await fetch(`${DATA_DIR}/${LIST_FILE}`);
    if(!res.ok) throw new Error();
    const map = await res.json();
    populatePicker(map);
  }catch{
    const dir = await (await fetch(`${DATA_DIR}/`)).text();
    const files=[...dir.matchAll(/href=\"([^"]+\\.csv)\"/gi)].map(m=>decodeURIComponent(m[1]));
    const map = Object.fromEntries(files.map(f=>[f,f]));
    populatePicker(map);
  }
})();

function populatePicker(obj){
  const sel=document.getElementById('picker');
  Object.entries(obj)
        .filter(([f])=>f.toLowerCase().endsWith('.csv'))
        .forEach(([file,title])=>{
          const opt=document.createElement('option');
          opt.value=file; opt.textContent=title||file;
          sel.appendChild(opt);
        });
}

document.getElementById('picker').addEventListener('change',async e=>{
  const file=e.target.value;
  if(!file) return;
  if(datasets.some(d=>d.label===file)) return; // già caricato
  const txt=await (await fetch(`${DATA_DIR}/${file}`)).text();
  const vec=parseCSV(txt);
  if(vec) addDataset(file,vec);
  e.target.selectedIndex=0;   // reset menu
});

function parseCSV(text){
  const lines=text.trim().split(/\r?\n/);
  if(lines.length<2) return null;
  const headers=lines[0].split(',').map(h=>h.trim());
  const store=Object.fromEntries(headers.map(h=>[h,[]]));
  for(let i=1;i<lines.length;i++){
    const nums=lines[i].split(',').map(parseFloat);
    nums.forEach((v,j)=>!isNaN(v)&&store[headers[j]].push(v));
  }
  return store;
}

function addDataset(name,vec){
  if(!vec) return;
  const keys = Object.keys(vec);
  const wlKey = keys[0];
  const yKey  = keys[1] || wlKey;
  const xs=vec[wlKey], ys=vec[yKey];
  const vecObj = {xs, ys};
  const color=colours[datasets.length%colours.length];
  const baseColor=color;
  const opacity=1;
  datasets.push({
    label: vec.title || name,
    data:xs.map((x,i)=>({x,y:ys[i]})),
    borderColor: `rgba(${parseInt(baseColor.slice(1,3),16)},${parseInt(baseColor.slice(3,5),16)},${parseInt(baseColor.slice(5,7),16)},${opacity})`,
    baseColor: baseColor,
    opacity: opacity,
    pointRadius:0,
    parsing:{xAxisKey:'x',yAxisKey:'y'},
    meta: vecObj            // <— aggiunto
  });
  chart.update();
  makeChip(name);
  refreshColours();
}

function makeChip(label){
  const chips=document.getElementById('chips');
  const span=document.createElement('span');
  span.className='chip';
  span.textContent='× '+label;
  span.addEventListener('click',()=>{
    datasets=datasets.filter(d=>d.label!==label);
    chart.data.datasets=datasets;
    chart.update();
    span.remove();
    colorInput.remove();
    alphaInput.remove();
  });
  const colorInput=document.createElement('input');
  colorInput.type='color';
  const ds=datasets.find(d=>d.label===label);
  colorInput.value=ds?ds.borderColor:'#ffffff';
  colorInput.style.marginLeft='6px';
  colorInput.addEventListener('input',e=>{
     const ds=datasets.find(d=>d.label===label);
     if(ds){
        ds.baseColor=e.target.value;
        refreshColours();
        chart.update();
     }
  });
  const alphaInput=document.createElement('input');
  alphaInput.type='range';
  alphaInput.min='10';alphaInput.max='100';alphaInput.value='100';
  alphaInput.style.width='70px';alphaInput.style.marginLeft='6px';
  alphaInput.addEventListener('input',e=>{
     const ds=datasets.find(d=>d.label===label);
     if(ds){ ds.opacity=parseInt(e.target.value,10)/100; refreshColours(); chart.update(); }
  });
  chips.appendChild(span);
  chips.appendChild(colorInput);
  chips.appendChild(alphaInput);
}

const overlay=document.getElementById('ccdOverlay');
document.getElementById('btnCCD').addEventListener('click',()=>{
  drawAllCCD();
  overlay.style.display='block';
});
document.getElementById('closeCCD').addEventListener('click',()=>{
  overlay.style.display='none';
});

function drawAllCCD(){
  const wrap=document.getElementById('ccdInner');
  wrap.innerHTML='';
  datasets.forEach(ds=>{
    const {xs,ys}=ds.meta;
    const maxY=Math.max(...ys);
    const row=document.createElement('div');
    row.className='ccdRow';
    const cv=document.createElement('canvas');
    cv.width=xs.length; cv.height=140;
    const ctx=cv.getContext('2d');
    ys.forEach((v,i)=>{
      const c=wavelengthToRGB(xs[i],v/maxY);
      ctx.fillStyle=`rgb(${c.r},${c.g},${c.b})`;
      ctx.fillRect(i,0,1,cv.height);
    });
    const label=document.createElement('span');
    label.textContent=ds.label;
    row.appendChild(cv);
    row.appendChild(label);
    wrap.appendChild(row);
  });
}

function wavelengthToRGB(w,f=1){
  let R=0,G=0,B=0;
  if(w>=380&&w<440){R=-(w-440)/60;B=1;}
  else if(w<490){G=(w-440)/50;B=1;}
  else if(w<510){G=1;B=-(w-510)/20;}
  else if(w<580){R=(w-510)/70;G=1;}
  else if(w<645){R=1;G=-(w-645)/65;}
  else if(w<=780){R=1;}
  f=Math.sqrt(f);
  return{r:Math.round(R*255*f),g:Math.round(G*255*f),b:Math.round(B*255*f)};
}

document.getElementById('btnNorm').addEventListener('click',()=>{
  normalized=!normalized;
  document.getElementById('btnNorm').textContent = normalized? 'Denormalize':'Normalize';
  datasets.forEach(ds=>{
    const ysOrig=ds.meta.ys;
    const max=Math.max(...ysOrig);
    ds.data=ds.meta.xs.map((x,i)=>({x,y: normalized? ysOrig[i]/max : ysOrig[i]}));
  });
  chart.update();
  drawAllCCD();
});

document.getElementById('chkLogY').addEventListener('change',e=>{
  logY=e.target.checked;
  chart.options.scales.y.type = logY ? 'logarithmic' : 'linear';
  chart.update();
});
</script>
</body>
</html>